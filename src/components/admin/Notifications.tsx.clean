'use client';

import { useEffect, useState } from 'react';
import { Bell, Calendar, User, MessageSquare, Clock, AlertCircle, CheckCircle, X } from 'lucide-react';
import { createClient } from '@/utils/supabase/client';
import { formatDistanceToNow } from 'date-fns';
import { cn } from '@/lib/utils';

type NotificationType = 'appointment' | 'inventory' | 'message' | 'user' | 'alert' | 'success';

interface NotificationData {
  [key: string]: string | number | boolean | null | undefined | Record<string, any>;
}

interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  createdAt: string;
  read: boolean;
  data?: NotificationData;
}

interface NotificationsProps {
  maxItems?: number;
  showMarkAllAsRead?: boolean;
  showClearAll?: boolean;
}

export function Notifications({ 
  maxItems = 5, 
  showMarkAllAsRead = true, 
  showClearAll = true 
}: NotificationsProps) {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);
  const [unreadCount, setUnreadCount] = useState(0);
  const supabase = createClient();

  // Fetch initial notifications
  useEffect(() => {
    const fetchNotifications = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return;

        const { data, error } = await supabase
          .from('notifications')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .limit(maxItems);

        if (error) throw error;

        const formattedNotifications = (data || []).map(notification => ({
          id: notification.id,
          type: notification.type as NotificationType,
          title: notification.title,
          message: notification.message,
          createdAt: notification.created_at,
          read: notification.read,
          data: notification.data
        }));

        setNotifications(formattedNotifications);
        updateUnreadCount(formattedNotifications);
      } catch (error) {
        console.error('Error fetching notifications:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchNotifications();
  }, [maxItems, supabase]);

  // Set up real-time subscription
  useEffect(() => {
    const setupRealtime = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const channel = supabase
        .channel('notifications_changes')
        .on('postgres_changes', 
          { 
            event: 'INSERT', 
            schema: 'public', 
            table: 'notifications',
            filter: `user_id=eq.${user.id}`
          }, 
          (payload) => {
            const newNotification = {
              id: payload.new.id,
              type: payload.new.type as NotificationType,
              title: payload.new.title,
              message: payload.new.message,
              createdAt: payload.new.created_at,
              read: payload.new.read,
              data: payload.new.data
            };
            
            setNotifications(prev => [newNotification, ...prev].slice(0, maxItems));
            setUnreadCount(prev => prev + 1);
            
            // Show browser notification if not focused
            if (document.visibilityState !== 'visible' && Notification.permission === 'granted') {
              new Notification(newNotification.title, {
                body: newNotification.message,
                icon: '/logo.png'
              });
            }
          }
        )
        .subscribe();

      return () => {
        supabase.removeChannel(channel);
      };
    };

    setupRealtime();
  }, [maxItems, supabase]);

  const updateUnreadCount = (notifs: Notification[]) => {
    const count = notifs.filter(n => !n.read).length;
    setUnreadCount(count);
  };

  const markAsRead = async (id: string) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .update({ read: true })
        .eq('id', id);

      if (error) throw error;

      setNotifications(prev => {
        const updated = prev.map(n => 
          n.id === id ? { ...n, read: true } : n
        );
        updateUnreadCount(updated);
        return updated;
      });
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  };

  const markAllAsRead = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const unreadIds = notifications.filter(n => !n.read).map(n => n.id);
      if (unreadIds.length === 0) return;

      const { error } = await supabase
        .from('notifications')
        .update({ read: true })
        .in('id', unreadIds);

      if (error) throw error;

      setNotifications(prev => {
        const updated = prev.map(n => ({ ...n, read: true }));
        updateUnreadCount(updated);
        return updated;
      });
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
    }
  };

  const clearAll = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('user_id', user.id);

      if (error) throw error;

      setNotifications([]);
      setUnreadCount(0);
    } catch (error) {
      console.error('Error clearing notifications:', error);
    }
  };

  const getNotificationIcon = (type: NotificationType) => {
    const iconClass = 'h-5 w-5 flex-shrink-0';
    
    switch (type) {
      case 'appointment':
        return <Calendar className={`${iconClass} text-blue-500`} />;
      case 'inventory':
        return <AlertCircle className={`${iconClass} text-amber-500`} />;
      case 'message':
        return <MessageSquare className={`${iconClass} text-green-500`} />;
      case 'success':
        return <CheckCircle className={`${iconClass} text-green-500`} />;
      case 'alert':
        return <AlertCircle className={`${iconClass} text-red-500`} />;
      case 'user':
        return <User className={`${iconClass} text-purple-500`} />;
      default:
        return <Bell className={`${iconClass} text-gray-500`} />;
    }
  };

  if (loading) {
    return (
      <div className="space-y-4 p-4">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-1/3 mb-2"></div>
            <div className="h-12 bg-gray-100 rounded"></div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="flow-root bg-white rounded-lg shadow">
      <div className="px-4 py-5 border-b border-gray-200 sm:px-6">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium leading-6 text-gray-900">
            Notifications {unreadCount > 0 && `(${unreadCount} new)`}
          </h3>
          <div className="flex space-x-2">
            {showMarkAllAsRead && unreadCount > 0 && (
              <button
                onClick={markAllAsRead}
                className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
              >
                Mark all as read
              </button>
            )}
            {showClearAll && notifications.length > 0 && (
              <button
                onClick={clearAll}
                className="text-sm font-medium text-gray-600 hover:text-gray-500"
              >
                Clear all
              </button>
            )}
          </div>
        </div>
      </div>
      
      {notifications.length === 0 ? (
        <div className="text-center py-8">
          <Bell className="mx-auto h-12 w-12 text-gray-400" />
          <h3 className="mt-2 text-sm font-medium text-gray-900">No notifications</h3>
          <p className="mt-1 text-sm text-gray-500">
            You'll see notifications here when you have them.
          </p>
        </div>
      ) : (
        <ul className="divide-y divide-gray-200 max-h-96 overflow-y-auto">
          {notifications.map((notification) => (
            <li 
              key={notification.id} 
              className={cn(
                'relative py-4 px-4 hover:bg-gray-50 cursor-pointer group',
                !notification.read ? 'bg-blue-50' : 'bg-white'
              )}
              onClick={() => !notification.read && markAsRead(notification.id)}
            >
              <div className="flex items-start">
                <div className="flex-shrink-0 pt-0.5">
                  {getNotificationIcon(notification.type)}
                </div>
                <div className="ml-3 flex-1 min-w-0">
                  <div className="flex justify-between">
                    <p className="text-sm font-medium text-gray-900">
                      {notification.title}
                    </p>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        // TODO: Implement delete single notification
                      }}
                      className="text-gray-400 hover:text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <X className="h-4 w-4" />
                    </button>
                  </div>
                  <p className="text-sm text-gray-500 mt-1">
                    {notification.message}
                  </p>
                  {notification.data?.link && (
                    <a 
                      href={notification.data.link as string}
                      className="mt-1 inline-flex items-center text-sm text-indigo-600 hover:text-indigo-500"
                      onClick={(e) => e.stopPropagation()}
                    >
                      View details
                    </a>
                  )}
                  <div className="mt-1 flex items-center text-xs text-gray-500">
                    <Clock className="flex-shrink-0 mr-1.5 h-3.5 w-3.5 text-gray-400" />
                    <span>
                      {formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true })}
                    </span>
                  </div>
                </div>
                {!notification.read && (
                  <div className="ml-4 flex-shrink-0">
                    <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                  </div>
                )}
              </div>
            </li>
          ))}
        </ul>
      )}
      
      <div className="bg-gray-50 px-4 py-3 text-center border-t border-gray-200">
        <a
          href="/dashboard/notifications"
          className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
        >
          View all notifications
        </a>
      </div>
    </div>
  );
}
